/**
  ******************************************************************************
  * @file    sysclk.c
  * @author  MCD Application Team
  * @version V1.2.0
  * @date    29-April-2015
  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
  *          This file contains the system clock configuration for STM32L1xx Ultra
  *          Low power devices, and is generated by the clock configuration
  *          tool  STM32L1xx_Clock_Configuration_V1.2.0.xls
  *
  * 1.  This file provides two functions and one global variable to be called from
  *     user application:
  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
  *                      and Divider factors, AHB/APBx prescalers and Flash settings),
  *                      depending on the configuration made in the clock xls tool.
  *                      This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32l1xx_xx.s" file.
  *
  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
  *                                  by the user application to setup the SysTick
  *                                  timer or configure other parameters.
  *
  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
  *                                 be called whenever the core clock is changed
  *                                 during program execution.
  *
  * 2. After each device reset the MSI (2.1 MHz Range) is used as system clock source.
  *    Then SystemInit() function is called, in "startup_stm32l1xx_xx.s" file, to
  *    configure the system clock before to branch to main program.
  *
  * 3. If the system clock source selected by user fails to startup, the SystemInit()
  *    function will do nothing and MSI still used as system clock source. User can
  *    add some code to deal with this issue inside the SetSysClock() function.
  *
  * 4. The default value of HSE crystal is set to 8MHz, refer to "HSE_VALUE" define
  *    in "stm32l1xx.h" file. When HSE is used as system clock source, directly or
  *    through PLL, and you are using different crystal you have to adapt the HSE
  *    value to your own configuration.
  *
  * 5. This file configures the system clock as follows:
  *=============================================================================
  *                         System Clock Configuration
  *=============================================================================
  *        System Clock source          | PLL(HSI)
  *-----------------------------------------------------------------------------
  *        SYSCLK                       | 32000000 Hz
  *-----------------------------------------------------------------------------
  *        HCLK                         | 32000000 Hz
  *-----------------------------------------------------------------------------
  *        AHB Prescaler                | 1
  *-----------------------------------------------------------------------------
  *        APB1 Prescaler               | 1
  *-----------------------------------------------------------------------------
  *        APB2 Prescaler               | 1
  *-----------------------------------------------------------------------------
  *        HSE Frequency                | 8000000 Hz
  *-----------------------------------------------------------------------------
  *        PLL DIV                      | 3
  *-----------------------------------------------------------------------------
  *        PLL MUL                      | 6
  *-----------------------------------------------------------------------------
  *        VDD                          | 3.3 V
  *-----------------------------------------------------------------------------
  *        Vcore                        | 1.8 V (Range 1)
  *-----------------------------------------------------------------------------
  *        Flash Latency                | 1 WS
  *-----------------------------------------------------------------------------
  *        Require 48MHz for USB clock  | Disabled
  *-----------------------------------------------------------------------------
  *=============================================================================
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32l1xx_system
  * @{
  */

/** @addtogroup STM32L1xx_System_Private_Includes
  * @{
  */

#include "define.h"
//#include "stm32l1xx.h"

/**
  * @}
  */

/** @addtogroup STM32L1xx_System_Private_TypesDefinitions
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32L1xx_System_Private_Defines
  * @{
  */

/*!< Uncomment the following line if you need to relocate your vector Table in
     Internal SRAM. */
/* #define VECT_TAB_SRAM */
#define VECT_TAB_OFFSET  0x0 /*!< Vector Table base offset field.
                                  This value must be a multiple of 0x200. */
/**
  * @}
  */

/** @addtogroup STM32L1xx_System_Private_Macros
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32L1xx_System_Private_Variables
  * @{
  */
uint32_t SystemCoreClock    = 32000000;
volatile const uint8_t PLLMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
volatile const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};

/**
  * @}
  */

/** @addtogroup STM32L1xx_System_Private_FunctionPrototypes
  * @{
  */

static void SetSysClock32(void);
static void SetSysClock16(void);
static void SetSysClock12(void);


/*****************************************************************
 SystemInit -     Initialise system clock before selecting speed
 Author:          B.Harris
 Inputs:          State pointer
 Outputs:         Nothing
 Date:            17/09/15
 *****************************************************************/
void SystemInit(void)
{
  RCC_CR|=(uint32_t)0x00000100;                                                         /* Enable MSI clock */
  RCC_CFGR&=(uint32_t)0x88FFC00C;                                                       /* MCO/1, MCO output disabled, PLL/4, *?? APBHS !div, APBLS !div, SYSCLK !div MSI as system clock */
  RCC_CR&=(uint32_t)0xEEFEFFFE;                                                         /* Clock security off, PLL off, HSE off, HSI off */
  RCC_CR&=(uint32_t)0xFFFBFFFF;                                                         /* Reset HSE bypass */
  RCC_CFGR&=(uint32_t)0xFF02FFFF;                                                       /* Reset PLLSRC, PLLMUL and PLLDIV */
  RCC_CIR=0x00000000;                                                                   /* Disable all interrupts */
}


/************************************************************
 SystemInit32 -     Initialise system clock tu run at 32mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
void SystemInit32(void)
{
  SystemInit();                                                                         /* Put clocks into known state */
  SystemCoreClock=32000000;                                                             /* Core clock set to 32mhz */
  SetSysClock32();                                                                      /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
}


/************************************************************
 SystemInit12 -     Initialise system clock tu run at 12mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
void SystemInit12(void)
{
  SystemInit();                                                                         /* Put clocks into known state */
  SystemCoreClock=12000000;                                                             /* Core clock set to 32mhz */
  SetSysClock12();                                                                      /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
}


/************************************************************
 SystemInit16 -     Initialise system clock tu run at 32mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
void SystemInit16(void)
{
  SystemInit();                                                                         /* Put clocks into known state */
  SystemCoreClock=16000000;                                                             /* Core clock set to 16mhz */
  SetSysClock16();                                                                      /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
}

/**
  * @brief  Update SystemCoreClock according to Clock Register Values
  *         The SystemCoreClock variable contains the core clock (HCLK), it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  *
  * @note   Each time the core clock (HCLK) changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  *
  * @note   - The system frequency computed by this function is not the real
  *           frequency in the chip. It is calculated based on the predefined
  *           constant and the selected clock source:
  *
  *           - If SYSCLK source is MSI, SystemCoreClock will contain the MSI
  *             value as defined by the MSI range.
  *
  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
  *
  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
  *
  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)
  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
  *
  *         (*) HSI_VALUE is a constant defined in stm32l1xx.h file (default value
  *             16 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *
  *         (**) HSE_VALUE is a constant defined in stm32l1xx.h file (default value
  *              8 MHz), user has to ensure that HSE_VALUE is same as the real
  *              frequency of the crystal used. Otherwise, this function may
  *              have wrong result.
  *
  *         - The result of this function could be not correct when using fractional
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
#ifndef RCC_CFGR_SWS
  #define RCC_CFGR_SWS              0x0000000c
#endif
#ifndef RCC_ICSCR_MSIRANGE
  #define RCC_ICSCR_MSIRANGE        0x0000e000
#endif
#ifndef HSI_VALUE
  #define HSI_VALUE                 16000000
#endif
#ifndef HSE_VALUE
  #define HSE_VALUE                 16000000
#endif
#ifndef RCC_CFGR_PLLMUL
  #define RCC_CFGR_PLLMUL           0x003c0000
#endif
#ifndef RCC_CFGR_PLLDIV
  #define RCC_CFGR_PLLDIV           0x00c00000
#endif
#ifndef RCC_CFGR_PLLSRC
  #define RCC_CFGR_PLLSRC           0x00010000
#endif
#ifndef RCC_CFGR_HPRE
  #define RCC_CFGR_HPRE             0x000000f0
#endif
#ifndef RCC_CR_HSION
  #define RCC_CR_HSION              0x00000001
#endif
#ifndef RCC_CR_HSIRDY
  #define RCC_CR_HSIRDY             0x00000002
#endif
#ifndef HSI_STARTUP_TIMEOUT
  #define HSI_STARTUP_TIMEOUT       ((uint16_t)0x5000)
#endif
#ifndef FLASH_ACR_ACC64
  #define FLASH_ACR_ACC64           0x00000004
#endif
#ifndef FLASH_ACR_PRFTEN
  #define FLASH_ACR_PRFTEN          0x00000002
#endif
#ifndef FLASH_ACR_LATENCY
  #define FLASH_ACR_LATENCY         0x00000001
#endif
#ifndef RCC_APB1ENR_PWREN
  #define RCC_APB1ENR_PWREN         0x10000000
#endif
#ifndef PWR_CR_VOS_0
  #define PWR_CR_VOS_0              0x00000900
#endif
#ifndef PWR_CSR_VOSF
  #define PWR_CSR_VOSF              0x00000010
#endif
#ifndef RCC_CFGR_HPRE_DIV1
  #define RCC_CFGR_HPRE_DIV1        0x00000000
#endif
#ifndef RCC_CFGR_PPRE2_DIV1
  #define RCC_CFGR_PPRE2_DIV1       0x00000000
#endif
#ifndef RCC_CFGR_PPRE1_DIV1
  #define RCC_CFGR_PPRE1_DIV1       0x00000000
#endif
#ifndef RCC_CFGR_PLLSRC_HSI
  #define RCC_CFGR_PLLSRC_HSI       0x00000000
#endif
#ifndef RCC_CFGR_PLLMUL6
  #define RCC_CFGR_PLLMUL6          0x00080000
#endif
#ifndef RCC_CFGR_PLLMUL3
  #define RCC_CFGR_PLLMUL3          0x00000000
#endif
#ifndef RCC_CFGR_PLLDIV3
  #define RCC_CFGR_PLLDIV3          0x00800000
#endif
#ifndef RCC_CFGR_PLLDIV4
  #define RCC_CFGR_PLLDIV4          0x00c00000
#endif
#ifndef RCC_CR_PLLON
  #define RCC_CR_PLLON              0x01000000
#endif
#ifndef RCC_CR_PLLRDY
  #define RCC_CR_PLLRDY             0x02000000
#endif
#ifndef RCC_CFGR_SW
  #define RCC_CFGR_SW               0x00000003
#endif
#ifndef RCC_CFGR_SW_PLL
  #define RCC_CFGR_SW_PLL           0x00000003
#endif
#ifndef RCC_CFGR_SWS_PLL
  #define RCC_CFGR_SWS_PLL          0x0000000C
#endif



void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmul = 0, plldiv = 0, pllsource = 0, msirange = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
//  tmp = RCC->CFGR & RCC_CFGR_SWS;
  tmp=RCC_CFGR&RCC_CFGR_SWS;
  
  switch(tmp)
  {
    case 0x00:  /* MSI used as system clock */
      msirange = (RCC_ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
      SystemCoreClock = (32768 * (1 << (msirange + 1)));
      break;
    case 0x04:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x08:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
      break;
    case 0x0C:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmul = RCC_CFGR & RCC_CFGR_PLLMUL;
      plldiv = RCC_CFGR & RCC_CFGR_PLLDIV;
      pllmul = PLLMulTable[(pllmul >> 18)];
      plldiv = (plldiv >> 22) + 1;

      pllsource = RCC_CFGR & RCC_CFGR_PLLSRC;

      if (pllsource == 0x00)
      {
        /* HSI oscillator clock selected as PLL clock entry */
        SystemCoreClock = (((HSI_VALUE) * pllmul) / plldiv);
      }
      else
      {
        /* HSE selected as PLL clock entry */
        SystemCoreClock = (((HSE_VALUE) * pllmul) / plldiv);
      }
      break;
    default: /* MSI used as system clock */
      msirange=(RCC_ICSCR&RCC_ICSCR_MSIRANGE)>>13;
      SystemCoreClock = (32768 * (1 << (msirange + 1)));
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC_CFGR&RCC_CFGR_HPRE)>>4)];
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
}


/************************************************************
 SetSysClock32 -    Initialise system clock to run at 32mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
static void SetSysClock32(void)
{
  uint32_t StartUpCounter=0,HSIStatus=0;

  RCC_CR|=((uint32_t)RCC_CR_HSION);                                                     /* Enable HSI clock */
  do                                                                                    /* Wait till HSI is ready and if Time out is reached exit */
  {
    HSIStatus=RCC_CR&RCC_CR_HSIRDY;
  } while((HSIStatus==0)&&(StartUpCounter!=HSI_STARTUP_TIMEOUT));
  if((RCC_CR&RCC_CR_HSIRDY)!=0)                                                         /* HSI clock ready? */
  {
    HSIStatus=(uint32_t)0x01;                                                           /* Flag "HSI ready" */
  }
  else
  {
    HSIStatus=(uint32_t)0x00;                                                           /* Flag "HSI not ready" */
  }
  if(HSIStatus==(uint32_t)0x01)                                                         /* HSI ready? */
  {
    FLASH_ACR|=FLASH_ACR_ACC64;                                                         /* Enable 64 bit access */
    FLASH_ACR|=FLASH_ACR_PRFTEN;                                                        /* Enable prefetch buffer */
    FLASH_ACR|=FLASH_ACR_LATENCY;                                                       /* 1 wait state */
    RCC_APB1ENR|=RCC_APB1ENR_PWREN;                                                     /* Enable power interface clock */
    PWR_CR=PWR_CR_VOS_0;                                                                /* 1.8V internal regulator */
    while((PWR_CSR&PWR_CSR_VOSF)!=0)                                                    /* Wait until voltage regulator is ready */
    {
    }
    RCC_CFGR|=(uint32_t)RCC_CFGR_HPRE_DIV1;                                             /* HCLK=SYSCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE2_DIV1;                                            /* PCLK2=HCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE1_DIV1;                                            /* PCLK1=HCLK/1 */
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC|RCC_CFGR_PLLMUL|RCC_CFGR_PLLDIV)); /* Reset PLL selection bits */
    RCC_CFGR|=(uint32_t)(RCC_CFGR_PLLSRC_HSI|RCC_CFGR_PLLMUL6|RCC_CFGR_PLLDIV3);        /* Select HSI clock * 6 / 3 */
    RCC_CR|=RCC_CR_PLLON;                                                               /* Enable PLL */
    while((RCC_CR&RCC_CR_PLLRDY)==0)                                                    /* Wait for PLL clock ready */
    {
    }
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_SW));                                     /* Reset clock source bits */
    RCC_CFGR|=(uint32_t)RCC_CFGR_SW_PLL;                                                /* PLL used as system clock source */
    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=(uint32_t)RCC_CFGR_SWS_PLL)                /* Wait for PLL to be switched as clock source */
    {
    }
//    RCC_CFGR|=0x01L;                                                                    /* HSI used as system clock source */
//    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=0x04L)                                     /* Wait for HSI to be switched as clock source */
//    {
//    }
  }
  else
  {
    /* If HSI fails to start-up, the application will have wrong clock
       configuration. User can add here some code to deal with this error */
  }
}


/************************************************************
 SetSysClock16 -    Initialise system clock to run at 16mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
static void SetSysClock16(void)
{
  uint32_t StartUpCounter=0,HSIStatus=0;

  RCC_CR|=((uint32_t)RCC_CR_HSION);                                                     /* Enable HSI clock */
  do                                                                                    /* Wait till HSI is ready and if Time out is reached exit */
  {
    HSIStatus=RCC_CR&RCC_CR_HSIRDY;
  } while((HSIStatus==0)&&(StartUpCounter!=HSI_STARTUP_TIMEOUT));
  if((RCC_CR&RCC_CR_HSIRDY)!=0)                                                         /* HSI clock ready? */
  {
    HSIStatus=(uint32_t)0x01;                                                           /* Flag "HSI ready" */
  }
  else
  {
    HSIStatus=(uint32_t)0x00;                                                           /* Flag "HSI not ready" */
  }
  if(HSIStatus==(uint32_t)0x01)                                                         /* HSI ready? */
  {
    FLASH_ACR&=~FLASH_ACR_ACC64;                                                        /* Disable 64 bit access */
    FLASH_ACR&=~FLASH_ACR_PRFTEN;                                                       /* Disable prefetch buffer */
    FLASH_ACR&=~FLASH_ACR_LATENCY;                                                      /* 0 wait states */
    RCC_APB1ENR|=RCC_APB1ENR_PWREN;                                                     /* Enable power interface clock */
    PWR_CR=PWR_CR_VOS_0;                                                                /* 1.8V internal regulator */
    while((PWR_CSR&PWR_CSR_VOSF)!=0)                                                    /* Wait until voltage regulator is ready */
    {
    }
    RCC_CFGR|=(uint32_t)RCC_CFGR_HPRE_DIV1;                                             /* HCLK=SYSCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE2_DIV1;                                            /* PCLK2=HCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE1_DIV1;                                            /* PCLK1=HCLK/1 */
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC|RCC_CFGR_PLLMUL|RCC_CFGR_PLLDIV)); /* Reset PLL selection bits */
    RCC_CFGR|=(uint32_t)(RCC_CFGR_PLLSRC_HSI|RCC_CFGR_PLLMUL3|RCC_CFGR_PLLDIV3);        /* Select HSI clock * 3 / 3 */
    RCC_CR|=RCC_CR_PLLON;                                                               /* Enable PLL */
    while((RCC_CR&RCC_CR_PLLRDY)==0)                                                    /* Wait for PLL clock ready */
    {
    }
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_SW));                                     /* Reset clock source bits */
    RCC_CFGR|=(uint32_t)RCC_CFGR_SW_PLL;                                                /* PLL used as system clock source */
    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=(uint32_t)RCC_CFGR_SWS_PLL)                /* Wait for PLL to be switched as clock source */
    {
    }
//    RCC_CFGR|=0x01L;                                                                    /* HSI used as system clock source */
//    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=0x04L)                                     /* Wait for HSI to be switched as clock source */
//    {
//    }
  }
  else
  {
    /* If HSI fails to start-up, the application will have wrong clock
       configuration. User can add here some code to deal with this error */
  }
}


/************************************************************
 SetSysClock12 -    Initialise system clock to run at 12mhz
 Author:            B.Harris
 Inputs:            State pointer
 Outputs:           Nothing
 Date:              17/09/15
 ************************************************************/
static void SetSysClock12(void)
{
  uint32_t StartUpCounter=0,HSIStatus=0;

  RCC_CR|=((uint32_t)RCC_CR_HSION);                                                     /* Enable HSI clock */
  do                                                                                    /* Wait till HSI is ready and if Time out is reached exit */
  {
    HSIStatus=RCC_CR&RCC_CR_HSIRDY;
  } while((HSIStatus==0)&&(StartUpCounter!=HSI_STARTUP_TIMEOUT));
  if((RCC_CR&RCC_CR_HSIRDY)!=0)                                                         /* HSI clock ready? */
  {
    HSIStatus=(uint32_t)0x01;                                                           /* Flag "HSI ready" */
  }
  else
  {
    HSIStatus=(uint32_t)0x00;                                                           /* Flag "HSI not ready" */
  }
  if(HSIStatus==(uint32_t)0x01)                                                         /* HSI ready? */
  {
    FLASH_ACR&=~FLASH_ACR_ACC64;                                                        /* Disable 64 bit access */
    FLASH_ACR&=~FLASH_ACR_PRFTEN;                                                       /* Disable prefetch buffer */
    FLASH_ACR&=~FLASH_ACR_LATENCY;                                                      /* 0 wait states */
    RCC_APB1ENR|=RCC_APB1ENR_PWREN;                                                     /* Enable power interface clock */
    PWR_CR=PWR_CR_VOS_0;                                                                /* 1.8V internal regulator */
    while((PWR_CSR&PWR_CSR_VOSF)!=0)                                                    /* Wait until voltage regulator is ready */
    {
    }
    RCC_CFGR|=(uint32_t)RCC_CFGR_HPRE_DIV1;                                             /* HCLK=SYSCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE2_DIV1;                                            /* PCLK2=HCLK/1 */
    RCC_CFGR|=(uint32_t)RCC_CFGR_PPRE1_DIV1;                                            /* PCLK1=HCLK/1 */
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC|RCC_CFGR_PLLMUL|RCC_CFGR_PLLDIV)); /* Reset PLL selection bits */
    RCC_CFGR|=(uint32_t)(RCC_CFGR_PLLSRC_HSI|RCC_CFGR_PLLMUL3|RCC_CFGR_PLLDIV4);        /* Select HSI clock * 3 / 4 */
    RCC_CR|=RCC_CR_PLLON;                                                               /* Enable PLL */
    while((RCC_CR&RCC_CR_PLLRDY)==0)                                                    /* Wait for PLL clock ready */
    {
    }
    RCC_CFGR&=(uint32_t)((uint32_t)~(RCC_CFGR_SW));                                     /* Reset clock source bits */
    RCC_CFGR|=(uint32_t)RCC_CFGR_SW_PLL;                                                /* PLL used as system clock source */
    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=(uint32_t)RCC_CFGR_SWS_PLL)                /* Wait for PLL to be switched as clock source */
    {
    }
//    RCC_CFGR|=0x01L;                                                                    /* HSI used as system clock source */
//    while((RCC_CFGR&(uint32_t)RCC_CFGR_SWS)!=0x04L)                                     /* Wait for HSI to be switched as clock source */
//    {
//    }
  }
  else
  {
    /* If HSI fails to start-up, the application will have wrong clock
       configuration. User can add here some code to deal with this error */
  }
}